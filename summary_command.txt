Pandas Summary

data = pd.read_csv('./data/colors.csv')
data['name'].nunique() #number of unique records

data.is_trans.value_counts()  #calculate number of record in "is_trans" column


dataset.iloc[[9521,9534]][["name","year"]]  # take row number 9521 and 9534; show column name and year

dataset.sort_values(by="num_parts",ascending=False).head()  # sort column num_part descending


#shift + tab to show document
#dir(dataset) : to show all method available

# check list method in pd which contain "series" word
[x for x in dir(pd) if 'series' in x.lower()]



#adjust NA value to 0
reshaped_df = reshaped_df.fillna(0) 
reshaped_df.fillna(0, inplace=True)

#create graph
plt.plot(reshaped_df.index,reshaped_df["java"]) 

import matplotlib.pyplot as plt

#some matplotlib config options

plt.figure(figsize=(16,10)) 

plt.xticks(fontsize=14)
plt.yticks(fontsize=14)

plt.xlabel('Date', fontsize=14)
plt.ylabel('Number of Posts', fontsize=14)
plt.ylim(0, 35000)


plt.plot(reshaped_df.index, reshaped_df.java)


#multiple column y categories in chart
for column in reshaped_df.columns:
    plt.plot(reshaped_df.index, reshaped_df[column])

# The window is number of observations that are averaged
roll_df = reshaped_df.rolling(window=6).mean()

# create line in plot if needed
#plt.plot(sets_by_year.index,sets_by_year.to_list())
plt.plot(sets_by_year.index,sets_by_year.values)
plt.plot([2000 for x in range(0,800,100)],[x for x in range(0,800,100)])

# plot the roll_df instead
for column in roll_df.columns:
    plt.plot(roll_df.index, roll_df[column], 
             linewidth=3, label=roll_df[column].name)

dataset.iloc[:-2] # takeout the last 2 index/row


# aggregate group by : count distint, count and sum; other option is max, dll

dataset.groupby('year').agg({'name':pd.Series.nunique,'theme_id':'count','num_parts':'sum'})


#create multiple axis chart


ax1 = plt.gca() # get current axis
ax2 = ax1.twinx() # get another axis that shares the same x-axis

ax1.plot(new_data.index,new_data["num_parts"],color='g')
ax2.plot(sets_by_year.index,sets_by_year.values,'b')

ax1.set_xlabel('Year')
ax1.set_ylabel('NUM_PARTS',color='green')
ax2.set_ylabel('NAMES',color='blue')


#additional styling for chart

# increases size and resolution
plt.figure(figsize=(14,8), dpi=120) 
plt.title('Tesla Web Search vs Price', fontsize=18)
 
ax1 = plt.gca()
ax2 = ax1.twinx()
 
# Also, increase fontsize and linewidth for larger charts
ax1.set_ylabel('TSLA Stock Price', color='#E6232E', fontsize=14)
ax2.set_ylabel('Search Trend', color='skyblue', fontsize=14)
 
ax1.plot(df_tesla.MONTH, df_tesla.TSLA_USD_CLOSE, color='#E6232E', linewidth=3)
ax2.plot(df_tesla.MONTH, df_tesla.TSLA_WEB_SEARCH, color='skyblue', linewidth=3)
 
# Displays chart explicitly
#plt.show()
---------------------------

plt.figure(figsize=(14,8), dpi=120)
plt.title('Tesla Web Search vs Price', fontsize=18)
 
# Increase the size and rotate the labels on the x-axis
plt.xticks(fontsize=14, rotation=45)
 
plt.figure(figsize=(14,8), dpi=120)
plt.title('Tesla Web Search vs Price', fontsize=18)
 
# Increase the size and rotate the labels on the x-axis
plt.xticks(fontsize=14, rotation=45)
 
ax1 = plt.gca()
ax2 = ax1.twinx()
 
ax1.set_ylabel('TSLA Stock Price', color='#E6232E', fontsize=14)
ax2.set_ylabel('Search Trend', color='skyblue', fontsize=14)
 
# Set the minimum and maximum values on the axes
ax1.set_ylim([0, 600])
ax1.set_xlim([df_tesla.MONTH.min(), df_tesla.MONTH.max()])
#ax2.set_ylim([0, 30])
 
ax1.plot(df_tesla.MONTH, df_tesla.TSLA_USD_CLOSE, color='#E6232E', linewidth=3)
ax2.plot(df_tesla.MONTH, df_tesla.TSLA_WEB_SEARCH, color='skyblue', linewidth=3)
 
plt.show()



#locator 

import matplotlib.dates as mdates

years = mdates.YearLocator()
months = mdates.MonthLocator()
years_fmt = mdates.DateFormatter('%Y')

#format the ticks

ax1.xaxis.set_major_locator(years)
ax1.xaxis.set_major_formatter(years_fmt)
ax1.xaxis.set_minor_locator(months)    
    
# Experiment with the linestyle and markers
ax1.plot(df_btc_monthly.index, df_btc_monthly.CLOSE, 
         color='#F08F2E', linewidth=3, linestyle='--',marker='^')
ax2.plot(df_btc_monthly.index, df_btc_search.BTC_NEWS_SEARCH, 
         color='skyblue', linewidth=3, marker='o')

# Show the grid lines as dark grey lines
ax1.grid(color='grey', linestyle='--')

# scatter plot

plt.scatter(sets_by_year.index,sets_by_year.values)
ax2.scatter(sets_by_year.index,sets_by_year.values)


# merge 2 table dataset and themes, with key join theme_id
merged_df = pd.merge(dataset,themes,on="theme_id")

# rename column name
dataset = dataset.rename(columns={'num_parts':'total_parts'})



# bar plot, with Series in the first 10 index and values

plt.bar(theme_name_summ.index[:10],theme_name_summ.values[:10])

plt.figure(figsize=(14,8))
plt.xticks(fontsize=14, rotation=45)
plt.yticks(fontsize=14)
plt.ylabel('Nr of Sets', fontsize=14)
plt.xlabel('Theme Name', fontsize=14)


#check missing value
df_tesla.isna().values.any()  #return True or False

df_tesla.isna().values.sum()  #return total missing value

df_tesla.isna().sum()  # find total NA breakdown per column

df_btc_price[df_btc_price["CLOSE"].isna()] # return specific row with missing value

df_btc_price = df_btc_price.dropna() #removing missing value
df_btc_price.dropna(inplace=True)


df_tesla.describe()

TSLA_WEB_SEARCH	TSLA_USD_CLOSE
count	124.000000	124.000000
mean	8.725806	50.962145
std	5.870332	65.908389
min	2.000000	3.896000
25%	3.750000	7.352500
50%	8.000000	44.653000
75%	12.000000	58.991999
max	31.000000	498.320007


df_tesla.TSLA_WEB_SEARCH.max()
df_tesla.TSLA_WEB_SEARCH.min()


#convert string to datetime object 

df_tesla.MONTH = pd.to_datetime(df_tesla.MONTH)
df_btc_search.MONTH = pd.to_datetime(df_btc_search.MONTH)

#resample from daily to monthly

df_btc_monthly = df_btc_price.resample('M', on='DATE').last()  # take the last date data for monthly
df_btc_monthly = df_btc_price.resample('M', on='DATE').mean() # take the average date data for monthly

roll_df = df_unemployment[['UE_BENEFITS_WEB_SEARCH', 'UNRATE']].rolling(window=6).mean()

#@@@@ DAY 75 


df_apps.sample(5) #take random sample from pandas


# Show numeric output in decimal format e.g., 2.15
pd.options.display.float_format = '{:,.2f}'.format

# remove unused column
df_apps.drop(["Last_Updated ","Android_Ver"],axis=1,inplace=True)


# check duplicated row
duplicated_rows = df_apps_clean[df_apps_clean.duplicated()]

# remove duplicates based on subset values
df_apps_clean = df_apps_clean.drop_duplicates(subset=['App','Type','Price'])

#calculate number of counts in content rating column
df_apps_clean["Content_Rating"].value_counts()


# check data type

df_apps_clean.Installs.describe()

df_apps_clean.info()

# convert string to number
df_apps_clean.Installs = df_apps_clean.Installs.astype(str).str.replace(',', "")
df_apps_clean.Installs = pd.to_numeric(df_apps_clean.Installs)
df_apps_clean[['App', 'Installs']].groupby('Installs').count()

# filtering condition in pandas
df_apps_clean = df_apps_clean[df_apps_clean['Price'] < 250]
df_apps_clean.sort_values('Price', ascending=False).head(5)

# multiple 2 column pandas
df_apps_clean['Revenue_Estimate'] = df_apps_clean.Installs.mul(df_apps_clean.Price)
df_apps_clean.sort_values('Revenue_Estimate', ascending=False)[:10]



# pie chart plotly
import pandas as pd
import plotly.express as px

fig = px.pie(labels=rating.index,values=rating.values)
fig.show()



fig = px.pie(labels=ratings.index,
values=ratings.values,
title="Content Rating",
names=ratings.index,
)
fig.update_traces(textposition='outside', textinfo='percent+label')
 
fig.show()

# count values events in particular column
top10_category = df_apps_clean.Category.value_counts()[:10]

#bar chart in plotly
top10_category = df_apps_clean.Category.value_counts()[:10]

bar = px.bar(x = top10_category.index, # index = category name
             y = top10_category.values)
 
bar.show()

# additional option for bar chart plotly

h_bar = px.bar(x = category_installs.Installs,
               y = category_installs.index,
               orientation='h',
               title='Category Popularity')
 
h_bar.update_layout(xaxis_title='Number of Downloads', yaxis_title='Category')
h_bar.show()

# addtional bar chart parameter optios
bar = px.bar(x = num_genres.index[:15], # index = category name
             y = num_genres.values[:15], # count
             title='Top Genres',
             hover_name=num_genres.index[:15],
             color=num_genres.values[:15],
             color_continuous_scale='Agsunset')
 
bar.update_layout(xaxis_title='Genre',
yaxis_title='Number of Apps',
coloraxis_showscale=False)
 
bar.show()

# addtional bar chart parameter optios

g_bar = px.bar(df_free_vs_paid,
               x='Category',
               y='App',
               title='Free vs Paid Apps by Category',
               color='Type',
               barmode='group')
 
g_bar.update_layout(xaxis_title='Category',
                    yaxis_title='Number of Apps',
                    xaxis={'categoryorder':'total descending'},
                    yaxis=dict(type='log'))
 
g_bar.show()


# box plot
box = px.box(df_apps_clean,
             y='Installs',
             x='Type',
             color='Type',
             notched=True,
             points='all',
             title='How Many Downloads are Paid Apps Giving Up?')
 
box.update_layout(yaxis=dict(type='log'))
 
box.show()


# other parameter options for box plot

df_paid_apps = df_apps_clean[df_apps_clean['Type'] == 'Paid']
box = px.box(df_paid_apps, 
             x='Category', 
             y='Revenue_Estimate',
             title='How Much Can Paid Apps Earn?')
 
box.update_layout(xaxis_title='Category',
                  yaxis_title='Paid App Ballpark Revenue',
                  xaxis={'categoryorder':'min ascending'},
                  yaxis=dict(type='log'))
 
 
box.show()




# scatter plot plotly
cat_number = df_apps_clean.groupby('Category').agg({'App': pd.Series.count})

cat_merged_df = pd.merge(cat_number, category_installs, on='Category', how="inner")
print(f'The dimensions of the DataFrame are: {cat_merged_df.shape}')
cat_merged_df.sort_values('Installs', ascending=False)

scatter = px.scatter(cat_merged_df, # data
                    x='App', # column name
                    y='Installs',
                    title='Category Concentration',
                    size='App',
                    hover_name=cat_merged_df.index,
                    color='Installs')
 
scatter.update_layout(xaxis_title="Number of Apps (Lower=More Concentrated)",
                      yaxis_title="Installs",
                      yaxis=dict(type='log'))
 
scatter.show()



# Split the strings on the semi-colon and then .stack them.
stack = df_apps_clean.Genres.str.split(';', expand=True).stack()
print(f'We now have a single column with shape: {stack.shape}')
num_genres = stack.value_counts()
print(f'Number of genres: {len(num_genres)}')


# group by as index=False

df_free_vs_paid = df_apps_clean.groupby(["Category", "Type"], as_index=False).agg({'App': pd.Series.count})
df_free_vs_paid.head()



#@@@@@@@@@DAY 76


my_array.ndim  #show dimensions of an array

array_2d[1,2]  # row number 2 and column number 3.. please note, it starts from 0

array_2d[0,:]  # row number 1 and all column values will be shown


a = np.arange(10,30,1) # create array a, start with 10, end with 30, step by 1 number [10 11 12 dst ...]


#tensor is referred as an array of 3 dimensions (or higher)


a[0:len(a):2]  # numpy slicer, 0= start; len(a) = end; 2 is step. better use : a[0::2]

a[-3:] # slice to the last 3 values


a[12:]	# # All the values except the first 12:

a[::2] # every second value (i.e., all the even values in our case)


np.flip(a)  # to reverse the order of array

a[::-1] # other option to reveres the order of array

nz_indices = np.nonzero(b)  # index from non-zero value in array


# generate random array
from numpy.random import random
z = random((3,3,3))
z

# create array with size =9 and value from 0 and 100
numpy.linspace(0,100,9)

noise = np.random.random((128,128,3))
print(noise.shape)
plt.imshow(noise)

#matrix multiplication
np.matmul(a1,b1)
img_gray = sRGB_array @ grey_vals # other option for matrix multiplication using @


import numpy as np
import matplotlib.pyplot as plt

from scipy import misc
from PIL import Image

sRGB_array = img / 255
grey_vals = np.array([0.2126, 0.7152, 0.0722])


img_gray = sRGB_array @ grey_vals
img_gray = np.matmul(sRGB_array, grey_vals)b

plt.imshow(img_gray, cmap='gray')


np.flip(img_gray)  # flip array 

np.rot90(img)  # rotate 90 degree


# open an image

my_img = Image.open(file_name)
img_array = np.array(my_img)

#@@@@@ DAY 78




data["USD_Production_Budget"].astype('str').str.replace("$","")


# replace string and convert to numeric
chars_to_remove = [',', '$']
columns_to_clean = ['USD_Production_Budget', 
                    'USD_Worldwide_Gross',
                    'USD_Domestic_Gross']
 
for col in columns_to_clean:
    for char in chars_to_remove:
        # Replace each character with an empty string
        data[col] = data[col].astype(str).str.replace(char, "")
    # Convert column to a numeric data type
    data[col] = pd.to_numeric(data[col])


# convert to datetime

data.Release_Date = pd.to_datetime(data.Release_Date)

# Descriptive Statistic
data.describe()

# Filter multiple condition
international_releases = data.loc[(data.USD_Domestic_Gross == 0) & 
                                  (data.USD_Worldwide_Gross != 0)]

# using query to filter multiple condition
international_releases = data.query('USD_Domestic_Gross == 0 and USD_Worldwide_Gross != 0')
print(f'Number of international releases: {len(international_releases)}')
international_releases.tail()


# drop some rows 
scrape_date = pd.Timestamp('2018-5-1')
future_released = data[data.Release_Date >= scrape_date]
data_clean = data.drop(future_released.index)


# seaborn scatter plot
import seaborn as sns

plt.figure(figsize=(8,4), dpi=200)
 
with sns.axes_style("darkgrid"):
    ax = sns.scatterplot(data=data_clean, 
                    x='Release_Date', 
                    y='USD_Production_Budget',
                    hue='USD_Worldwide_Gross',
                    size='USD_Worldwide_Gross',)
 
    ax.set(ylim=(0, 450000000),
           xlim=(data_clean.Release_Date.min(), data_clean.Release_Date.max()),
           xlabel='Year',
           ylabel='Budget in $100 millions')


# create datetime Index from release date column

dt_index = pd.DatetimeIndex(data_clean.Release_Date)
years = dt_index.year

decades = years//10*10
data_clean['Decade'] = decades
old_films = data_clean[data_clean.Decade <= 1960]
new_films = data_clean[data_clean.Decade > 1960]


# seaborn regresion plot
plt.figure(figsize=(8,4), dpi=200)
with sns.axes_style("whitegrid"):
  sns.regplot(data=old_films, 
            x='USD_Production_Budget', 
            y='USD_Worldwide_Gross',
            scatter_kws = {'alpha': 0.4},
            line_kws = {'color': 'black'})

# other parameter option seaborn regression plot
plt.figure(figsize=(8,4), dpi=200)
with sns.axes_style('darkgrid'):
  ax = sns.regplot(data=new_films,
                   x='USD_Production_Budget',
                   y='USD_Worldwide_Gross',
                   color='#2f4b7c',
                   scatter_kws = {'alpha': 0.3},
                   line_kws = {'color': '#ff7c43'})
  
  ax.set(ylim=(0, 3000000000),
         xlim=(0, 450000000),
         ylabel='Revenue in $ billions',
         xlabel='Budget in $100 millions') 

#### Regression

# Explanatory Variable(s) or Feature(s)
X = pd.DataFrame(new_films, columns=['USD_Production_Budget'])
 
# Response Variable or Target
y = pd.DataFrame(new_films, columns=['USD_Worldwide_Gross']) 

# Find the best-fit line
regression.fit(X, y)

# equation y = mx+c ; m--> slope/coef (theta one)  c--> y-axis intercept (theta zero)

# Theta zero
regression.intercept_

# Theta one
regression.coef_

# R-squared
#This means that our model explains about 56% of the variance in movie revenue.

regression.score(X, y)

# other regression sample
X = pd.DataFrame(old_films, columns=['USD_Production_Budget'])
y = pd.DataFrame(old_films, columns=['USD_Worldwide_Gross'])
regression.fit(X, y)
print(f'The slope coefficient is: {regression.coef_[0]}')
print(f'The intercept is: {regression.intercept_[0]}')
print(f'The r-squared is: {regression.score(X, y)}')


# prediction

budget = 350000000
revenue_estimate = regression.intercept_[0] + regression.coef_[0,0]*budget
revenue_estimate = round(revenue_estimate, -6)
print(f'The estimated revenue for a $350 film is around ${revenue_estimate:.10}.')





